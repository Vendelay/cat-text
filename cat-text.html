<link rel="import" href="../polymer/polymer.html">
<!--
`cat-text` is an element that displays a text with a transition effect. Although the same appearance
can be obtained with pure CSS transitions, the cat-text true power is revealed when used in conjunction
with other elements, like `cat-image`

@element cat-text
@demo demo/index.html 
-->

<dom-module id="cat-text">
    <style>
        :host {          
            display: inline-block;
            position: relative;
        }
    </style>
    
    <template>
        <div>
            <content></content>
        </div>
    </template>
    
    <script>

    (function(){

    'use strict';

    // the code ouside Polymer({}) is run once even for multiple component instances
    var directions = {
            'center': ['0', '0', '50% 50%'],
            'top': ['1', '0', '100% 0%'],
            'left': ['0', '1', '0% 100%'],
            'bottom': ['1', '0', '100% 100%'],
            'right': ['0', '1', '100% 100%']
        },
        possibleFunctions = ['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear'],
        possibleDirections = ['center', 'left', 'right', 'top', 'bottom'];

    Polymer({

        //private vars
        _useTransition : true,
        _useFade : false,
        _useScale : false,
        _useSlide : false,
        _transitionPropertyString : '',

        is: 'cat-text',
        
        properties: {
            /**
             * Available options: fade, slide, scale (or combined, space delimited)
             */
            transitionType: {
                type: String,
                value: 'scale'
            },
            /**
             * Available options: center, left, right, top, bottom. 'center' is unavailable for transitionType: slide, 
             */
            transitionDirection: {
                type: String,
                value: 'center'
            },
            /**
             * Easing function. Available options: ease, linear, ease-in, ease-out, ease-in-out
             */
            transitionFunction: {
                type: String,
                value: 'ease'
            },
            /**
             * Easing duration, in seconds
             */
            transitionDuration: {
                type: Number,
                value: 1
            },
            /**
             * Transition delay, in seconds
             */
            transitionDelay: {
                type: Number,
                value: 0
            },
            /**
             * Available only for Transition type: slide
             */
            slideOffset: {
                type: Number,
                value: 100
            },
            /**
             * By default, the text will appear only when it is in the viewport (visible area).
             * Enable this if you want to make it visible on load.
             */
            visibleOnLoad: { //as opposed to visible on viewport
                type: Boolean,
                value: false
            },
            /**
             * Enable this when you include cat-text in another component and you trigger the text appearance programatically (via showText())
             */
            manuallyTriggered: {
                type: Boolean,
                value: false
            }
        },

        listeners: {
            'show': 'showText',
            'hide': 'hideText'
        },

        _errorHandling: function() {
            if (possibleFunctions.indexOf(this.transitionFunction) === -1) {
                this.transitionFunction = 'ease';
            }
            if (possibleDirections.indexOf(this.transitionDirection) === -1) {
                this.transitionDirection = 'center';
            }
        },

        _transitionTypeHandling: function() {
            var types = this.transitionType.split(' ');
            if (types.indexOf('none') > -1) {
                this._useTransition = false;
            } else {
                if (types.indexOf('fade') > -1) this._useFade = true;
                if (types.indexOf('scale') > -1) this._useScale = true;
                if (types.indexOf('slide') > -1) {this._useSlide = true; this._useFade = true;}

                if (!this._useFade && !this._useScale && !this._useSlide) {
                    this._useTransition = false;
                }                
            }
        },

        // setting up initial values for css properties that use transitions
        _initialStyleSetup: function() {
            if (this._useTransition) {

                this.style.opacity = '0';

                if (this._useScale) {                    
                    this.style.transformOrigin = directions[this.transitionDirection][2];

                    this.style.transform = 'scale3d(' +
                        directions[this.transitionDirection][0]+', '+
                        directions[this.transitionDirection][1] +', 1)';
                }

                if (this._useSlide) {
                    if (this.transitionDirection === 'center') {
                        this.transitionDirection = 'top';
                    }
                    this.style[this.transitionDirection] = '-' + this.slideOffset + 'px';
                }
            }
        },

        // wrapping all style changes in a function in order to trigger it below either
        // on visible in viewport or on page load
        _applyStyles: function() {
            
            this.style.transitionDuration = this.transitionDuration + 's';
            this.style.transitionDelay = this.transitionDelay + 's';            
            this.style.transitionTimingFunction = this.transitionFunction;

            this._transitionPropertyString = '';
            this.style.opacity = 1;
            
            if (this._useFade) {
                this._transitionPropertyString += ' opacity';
            }
            if (this._useScale) {
                this._transitionPropertyString += ' transform';
                this.style.transform = 'scale3d(1, 1, 1)';
            }
            if (this._useSlide) {
                this._transitionPropertyString += ' top left right bottom';
                
                this.style.left = 0;
                this.style.right = 0;              
                this.style.top = 0;
                this.style.bottom = 0;
                if (this.transitionDirection === 'right') this.style.left = 'auto';
                if (this.transitionDirection === 'bottom') this.style.top = 'auto';
            }

            this._transitionPropertyString = this._transitionPropertyString.trim().split(' ').join(',');

            this.style.transitionProperty = this._transitionPropertyString;

        },

        showText: function() {
            var self = this;          

            if (self._useTransition) {
                if (!self.visibleOnLoad && !self.manuallyTriggered) {
                    onVisibleOnce(self, self.slideOffset, function() {
                        self._applyStyles();
                    });
                } else {
                    self._applyStyles();
                }                

            }
        },

        hideText: function() {
            var self = this;

            this.style.transition = 'none';

            if (this._useTransition) {

                this.style.opacity = 0;
                
                if (this._useScale) {                    
                    this.style.transformOrigin = directions[this.transitionDirection][2];

                    this.style.transform = 'scale3d(' +
                        directions[this.transitionDirection][0]+', '+
                        directions[this.transitionDirection][1] +', 1)';
                }

                if (this._useSlide) {                    
                    this.style[this.transitionDirection] = '-' + this.slideOffset + 'px';
                }
            }
        },

        attached: function() {
            this._errorHandling();        
            this._transitionTypeHandling();            
            this._initialStyleSetup();

            if (!this.manuallyTriggered) {
                this.showText();
            }
        }
    });




    // functions to check if an element is in the viewport
    function isElementInViewport(el, offset) {       
        var rect = el.getBoundingClientRect();
        offset = offset ? offset : 0;
        return (
            rect.top >= -offset &&
            rect.left >= -offset &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) +offset &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth) + offset
        );
    }

    function onVisibleOnce(el, offset, callback) {            
        var visibilityCheck = function() {
            if (isElementInViewport(el, offset)) {
                callback();
                removeEventListener('DOMContentLoaded', visibilityCheck, false); 
                removeEventListener('load', visibilityCheck, false); 
                removeEventListener('scroll', visibilityCheck, false); 
                removeEventListener('resize', visibilityCheck, false);
            }
        };

        addEventListener('DOMContentLoaded', visibilityCheck, false); 
        addEventListener('load', visibilityCheck, false); 
        addEventListener('scroll', visibilityCheck, false); 
        addEventListener('resize', visibilityCheck, false);

        visibilityCheck();
    }
    //

    })();

    </script>

</dom-module>
